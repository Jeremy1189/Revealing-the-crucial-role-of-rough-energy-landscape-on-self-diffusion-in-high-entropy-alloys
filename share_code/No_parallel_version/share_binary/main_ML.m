%%Discreption: This code aims to combine the ML model with the kMC by using
%%the Coordinate system transfer methods.

% Author: xubiao1189@gmail.com
% Group: Dr Shijun Zhao in MNE in City University of Hongkong
% time : 2021/12/13

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% clear other data and add function path

clc;
clear;
addpath(genpath(pwd));
rng('default');
% close all

%% load the trained Machine Learning Model
load best_model_FE_NiFe.mat best_model_FE_NiFe
load best_model_EBF_NiFe.mat best_model_EBF_NiFe
best_model = best_model_EBF_NiFe;

%% load the standard coordinate data and setting initial data
% read a reference structure, and the structure difference between NiFe and NiFeCr is just
% change the types and lattice constant;(this structure generated by the software Atomsk) 

load per_input.mat per_input
lattice_constant_ini=3.488; % the lattice constant of the reference perfect strcuture
super_size_length=10;
vacancy_atomID=2221;% initial vacancy position (center postition of the structure)
migration_atomID=vacancy_atomID+1; %   this ID can be an anbitray atom of the 12 nearest neigbors of vacancy atom
per_index = per_input(1,:);
per_coords =  per_input(3:5,:);
vac_coord= per_coords(:,vacancy_atomID);

fix_point=10^8; % this is a setting to control the fixed-point arithmetic 

ratio=(0:0.05:1)'; % the Ni ratio in Ni(x)Fe 
% the optimized lattice constant for the Bonny 2011
lattice_constant_set = [3.4989,3.4948,3.4921,3.4901, 3.4888,3.4879,3.4872,3.4873,...
3.4875,3.4877,3.4882,3.4892,3.4907,...%0.4-0.6
3.4923,3.4945,3.4967,3.4996,...%0.65-0.8
3.5035,3.5077,3.5132,3.5195];%0.85-1


NN1=12;%fcc 1st nearest neigbors(NN)
NN_ML=5;% 5NN both from migration atom and vacancy
cos_flag=1;% 1 or 2
[vac_ID_nn_set,vac_ID_count_set,~] ...
            = vac_coords_trans(vac_coord',per_coords',per_index,lattice_constant_ini,super_size_length);
cum_vac_IDs=cumsum(vac_ID_count_set);  
nn5_vac_num = cum_vac_IDs(6)-1;%5nn is the 6th number and the 1st is the vacancy       
NN=1;
NN1_atomIDs = vac_ID_nn_set(NN+1:vac_ID_count_set(NN+1)+1);%1st ID is the vacancy  
%% obtain the reference coordinate
[standard_coords,standard_axis_x,standard_axis_y]= coordinates_transfer(vacancy_atomID,migration_atomID,per_coords,...
    lattice_constant_ini,super_size_length,NN_ML,cos_flag);
axis_x_set=zeros(length(NN1_atomIDs),3);
axis_y_set=zeros(length(NN1_atomIDs),3);
stand_sort_index_set=zeros(length(NN1_atomIDs),length(standard_coords));

%% initalization other parameters
perfect_coord=per_coords;
perfect_types=per_input(2,:);%NiFe
N=length(per_index)-1;
% iteration
iter_times=30e4;%kMC steps
Kb= 0.025852/300 ;% ev Boltzmann constant
D0=1*10^13;%HZ
%kmc
T_set=900:200:1300;% temperature
%% parallel calculation setting,(if you debug the code, I recommend you to comment the
% following 3 line and the 'parfor' line for quickly dianose the problem)
% delete(gcp('nocreate'));
% core_number=length(ratio);
% parpool('local',core_number);
for num_T=1:length(T_set)
    T=T_set(num_T);
    L_r=length(ratio);
    D=zeros(L_r,1);
    D_Fe=zeros(L_r,1);
    D_Ni=zeros(L_r,1);
    f_tracer_all=zeros(L_r,1);
    f_tracer_Fe=zeros(L_r,1);
    f_tracer_Ni=zeros(L_r,1);
    Mig_prob=zeros(L_r,1);
    
% parfor num_ratio=1:L_r% 

for  num_ratio=1:L_r %
    
 %% initialize the vacancy coordinate for each ratio
    vac_ID= vacancy_atomID;
    mig_ID=migration_atomID;
    %% update the lattice constant and coordinates
    lattice_constant=lattice_constant_set(num_ratio);% lattice constant for current ratio
    Len = lattice_constant*super_size_length;% box length
    per_coords = perfect_coord ;
    per_type=perfect_types;
    per_coords =per_coords./lattice_constant_ini.*lattice_constant;
    
    %% initialize the MSD coordinate
    R0=per_coords;
    Rt=per_coords;
    
    %% update the types form NiFe to NiFe with current ratio
    num_atoms=length(per_coords);
    element_type=[1,2];%1 Ni, 2 Fe
    L= length( element_type);
    num_atoms_all=zeros(L,1);
    for i= 1:L-1
        num_atoms_all(i)= round(num_atoms*ratio(num_ratio,i));
    end
    num_atoms_all(L)= num_atoms-sum(num_atoms_all); % the number of the remain element
    cumsum_set = cumsum(num_atoms_all);
    per_type(1:cumsum_set(1))=element_type(1);% Ni%
    for j = 2: L
        per_type(  (cumsum_set(j-1)+1) :cumsum_set(j))=element_type(j);
    end
    rand_index = randperm(num_atoms);
    per_type = per_type(rand_index);
    
    %% initialization cell and array
    t=0;% inital tim
    count0=0;count60=0;count90=0;count120=0;count180=0;
    cos_value_set=zeros(iter_times,1);
    tracks= zeros(iter_times,7); %[t,vac_x,vac_y,Vac_z,MSD]
    NN1_mig_energy_set1 =zeros(iter_times,NN1);%
    mig_index_set =zeros(iter_times,1);
    K_tot_set_rng=zeros(iter_times,1);
%     per_type_set=zeros(length(per_type),iter_times);
    output_FE_set=zeros(iter_times,NN1);
    mig_type_set = zeros(iter_times,14);% [mig_type, vac_type, 12 NN1_type]
    cross_boundary_count=zeros(3,length(per_index));
   all_atom_set=zeros(iter_times,4);% the first column is the index, the 2:4 columns are the coordinate of the atoms after migration
   Ni_index=find(per_type==1);
   Fe_index=find(per_type==2);
   for count=1:iter_times
        %% calculating MSD
      
        vac_coord=per_coords(:,vac_ID);% updated the vacancy position
        Dt =Rt-R0;
        if mod(count,1e4)==0
            disp(count)
        end
        %             Dt(index) =Len-Dt(index);
        Dt=Dt+Len.* cross_boundary_count;
        sum_Dt=sum(Dt.^2);%
        sum_Dt(vacancy_atomID)=0;
        MSD =sum(sum_Dt)./N;
        %partitial MSD
        if ~isempty(Fe_index)
            sum_Fe= sum_Dt(Fe_index);
            r_index=find(Fe_index==vac_ID);
            sum_Fe(r_index)=[];
            current_index=Fe_index;
            current_index(r_index)=[];
            MSD_Fe=sum(sum_Fe)./length(current_index);
        else
            MSD_Fe=0;
        end
        if ~isempty(Ni_index)
            sum_Ni= sum_Dt(Ni_index);
            r_index=find(Ni_index==vac_ID);
            sum_Ni(r_index)=[];
            current_index=Ni_index;
            current_index(r_index)=[];
            MSD_Ni =sum(sum_Ni)./length(current_index);
        else
            MSD_Ni=0;
        end
        tracks(count,:)=[t;vac_coord;MSD;MSD_Fe;MSD_Ni]';
        %         tracks(count,:)=[t;vac_coord;MSD]';
        %% using the CST to adjust the coordinate in the kMC
        [vac_ID_nn_set,~,~,~,~] ...
            = update_vac_nn_kmc(vac_ID,mig_ID,per_coords',lattice_constant,super_size_length);

        NN1_ID_set = vac_ID_nn_set(1:NN1); 
%         NN1_ID_set_lammps(:,count)= NN1_ID_set;
        stand_sort_index_set=zeros(length(NN1_atomIDs),length(standard_coords));
        input_atomID_set=zeros(NN1,length(stand_sort_index_set)+1);%1 is mig
        for num_mig_NN1 =1:NN1  
          %update mig_ID
            mig_ID = NN1_ID_set(num_mig_NN1); 
            vac_mig_vector =( per_coords(:,mig_ID)-per_coords(:,vac_ID));
            norm_vac_mig_vector=vac_mig_vector./norm(vac_mig_vector);
           %match the axis x
            [new_coords,~,~]= coordinates_transfer(vac_ID,mig_ID,per_coords,...
                lattice_constant,super_size_length,NN_ML,cos_flag);
            for num_coords = 1:length(standard_coords)
                sum_diff= sum( abs(repmat(standard_coords(:,num_coords),[1,length(standard_coords)] )- new_coords),1 );
                sum_diff =round(sum_diff.*fix_point)./fix_point;
                index_p= find(sum_diff==0);
                stand_sort_index_set(num_mig_NN1,num_coords)  =index_p;% the sort order for the migration atom during the kMC
            end
              current_vac_mig_order =  stand_sort_index_set(num_mig_NN1,:);
            %update the atom_env 
            [~,~,vac_mig_sortID_nn_set,vac_mig_nn_count_set]=update_vac_nn_kmc(vac_ID,mig_ID,per_coords',lattice_constant,super_size_length);
            cum_count =cumsum(vac_mig_nn_count_set);
            NN_vac_mig_atom_ID_set=vac_mig_sortID_nn_set(1: cum_count(NN_ML));
            NN_order_ID_input= NN_vac_mig_atom_ID_set(current_vac_mig_order);
            input_atomID_set(num_mig_NN1,:)=[mig_ID ;NN_order_ID_input]';
        end
    
        %% predicting the energy by machine learning model
        Mig_IDs=input_atomID_set(:,1);
        per=[per_index;per_type;per_coords]';
        input_type_set = per_type(input_atomID_set);
        input_equal_position_set= input_type_set;
        X0=dec2bin_alloy2(input_equal_position_set);
        NN1_mig_energy_set = best_model(X0');
        
        test_EBF=NN1_mig_energy_set';
        
        NN1_output_FE=  best_model_FE_NiFe(X0');
        
        test_FE = NN1_output_FE';
        
        output_FE_set(count,:)=NN1_output_FE; 
        %% KMC
        NN1_mig_energy_set1(count,:)=NN1_mig_energy_set;
        K_set= D0.*exp(-(NN1_mig_energy_set)./(Kb*T));
        K_tot =sum(K_set);
        K_tot_set_rng(count)=K_tot;
        cum_k_set= cumsum(K_set);
        roulette_k_set = cum_k_set./K_tot;
        r1 =rand(1);
        mig_index = find(r1-roulette_k_set <0,1);
        r2 =rand(1);
        t = t + -1/K_tot* log(r2);
        
        %% update the Rt and vancancy coordinate
        NN1_mig_atomID = input_atomID_set(:,1);
        mig_ID =   NN1_mig_atomID(mig_index);
        mig_index_set(count)=mig_index;
        mig_coord = per_coords(:,mig_ID);
        mig_type_set(count,:)= [per_type(vac_ID),per_type(mig_ID),per_type(NN1_mig_atomID)];
        vac_coord = per_coords(:,vac_ID);
%         Rt(:,mig_ID) =Rt(:,mig_ID)+(vac_coord-mig_coord);
        %% jump record
        current_jump_vector=vac_coord-mig_coord;
        index_out_L= find(current_jump_vector>=0.5*Len);
        current_jump_vector(index_out_L)=current_jump_vector(index_out_L)-Len;
        index_out_R= find(current_jump_vector<-0.5*Len);
        current_jump_vector(index_out_R)=current_jump_vector(index_out_R)+Len;
        % statistic cos 
        if count==1
            forward_jump_vector=current_jump_vector;
            cos_set = cosd([0,60, 90,120,180]);
        end
        cos_value_set(count) = dot(forward_jump_vector,current_jump_vector)/( norm(forward_jump_vector)*norm(current_jump_vector));
        [min_value,index_set] = min(abs(cos_value_set(count)-cos_set));
        switch index_set
            case 1
                count0=count0+1;
            case 2
                count60=count60+1;
            case 3
                count90=count90+1;
            case 4
                count120=count120+1;
            case 5
                count180=count180+1;
            otherwise
                disp("error index")
        end
        
        forward_jump_vector=current_jump_vector;
        
                   % check the periodic bangdary
            Rt(:,mig_ID) =Rt(:,mig_ID)+current_jump_vector;
            Rt_coords=Rt(:, mig_ID);            
            index_out_U= find(Rt_coords>Len);
            cross_boundary_count(index_out_U,mig_ID)= cross_boundary_count(index_out_U,mig_ID)+1;
%             if ~isempty(index_out_U)
%                 disp(['out_right',num2str(count)]);
%             end
            Rt_coords(index_out_U)= Rt_coords(index_out_U)-Len;
            
            index_out_L= find(Rt_coords<0);
            cross_boundary_count(index_out_L,mig_ID)= cross_boundary_count(index_out_L,mig_ID)-1;
%             if ~isempty(index_out_L)
%                 disp(['out_left',num2str(count)]);
%             end
            Rt_coords(index_out_L)= Rt_coords(index_out_L)+Len;
            Rt(:, mig_ID)=Rt_coords;
            
        %   exchange the coordinate of vacancy and migration atom
        per_coords(:,mig_ID) = vac_coord;
        per_coords(:,vac_ID)= mig_coord;
        per_type(vac_ID)=per_type(mig_ID);
%         if mod(count,1e3)==0 %debug 
%             
%            Rt_temp_cell{count/1e3}=[Rt;per]; 
%            cross_boundary_cell{count/1e3}=cross_boundary_count;
%         end

         all_atom_set(count,:)=[mig_ID,per_coords(:,mig_ID)']; 
    end
    % calculate the MSD and f_tracer
    t_set=tracks(:,1);
    MSD_t=tracks(:,5);
    MSD_Fe=tracks(:,6);
    MSD_Ni=tracks(:,7);
    p0= polyfit(t_set, MSD_t,1);
    p1= polyfit(t_set, MSD_Fe,1);
    p2= polyfit(t_set, MSD_Ni,1);
    x0=0:max(t_set)/1e3:max(t_set);
    y0= polyval(p0,x0);
    y1= polyval(p1,x0);
    y2= polyval(p2,x0);
    D(num_ratio)=p0(1)./6;
    D_Fe(num_ratio)=p1(1)./6;
    D_Ni(num_ratio)=p2(1)./6;
    Ni_mig_num= length(find(mig_type_set(:,2)==1));
    Fe_mig_num= length(find(mig_type_set(:,2)==2));
    unit_a=lattice_constant^2/2;
    f_tracer_all(num_ratio)= MSD_t(end)/((length(MSD_t)/N) * unit_a);
    if  ~isempty(Fe_index)
        r_index=find(Fe_index==vac_ID);
        current_index=Fe_index;
        current_index(r_index)=[];
        f_tracer_Fe(num_ratio)= MSD_Fe(end)/( Fe_mig_num/length(current_index) * unit_a);
        %            disp('f_tracer_Fe')
        %            disp(f_tracer_Fe)
    end
    if  ~isempty(Ni_index)
        r_index=find(Ni_index==vac_ID);
        current_index=Ni_index;
        current_index(r_index)=[];
        f_tracer_Ni(num_ratio)= MSD_Ni(end)/(Ni_mig_num/length(current_index) * unit_a);
    end
    % save the data
    
    Mig_prob(num_ratio)=Fe_mig_num/(Fe_mig_num+Ni_mig_num);
    R_t{num_ratio}=Rt;
    R_0{num_ratio}=R0;
    disp(num2str(D(num_ratio)));
    cos{num_ratio}=cos_value_set;
    tracks_set{num_ratio}=tracks;
    k_tot_avg_set{num_ratio}= K_tot_set_rng;
    count_degree(num_ratio,:)=[count0,count60,count90,count120,count180];
    NN1_mig_energy_cell{num_ratio}=NN1_mig_energy_set1;
    vac_mig_NN1_type_set{num_ratio}=mig_type_set;
    mig_index_cell{num_ratio}=mig_index_set;
    output_FE_set_ratios{num_ratio}=output_FE_set;
    all_atom_set_cell{num_ratio}=all_atom_set;
    per_cell{num_ratio}=per;
    %      cross_boundary_cell_set{num_ratio}=cross_boundary_cell;
    %       Rt_temp_cell_set{num_ratio}=Rt_temp_cell;
%  per_vac_type_cell{num_ratio}= per_vac_type;
end
   D_set{num_T}=D;
   save (['ML_',num2str(T_set(num_T)),'k.mat'])
end

